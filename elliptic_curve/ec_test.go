package elliptic_curve

import (
	"fmt"
	"math/big"
	"math/rand"
	"testing"
)

func SolveField19MultiplySet() {
	//randomly select a num from (1, 18)
	minimum := 1
	maximum := 18
	k := rand.Intn(maximum-minimum) + minimum
	fmt.Printf("randomly select k is : %d\n", k)
	element := NewFieldElement(big.NewInt(19), big.NewInt(int64(k)))
	for i := 0; i < 19; i++ {
		fmt.Printf("element %d multiplie with %d is %v\n", k, i,
			element.ScalarMul(big.NewInt(int64(i))))
	}

}

/*
p = 7, 11, 17, 19, 31, what would the following set be:
{1 ^(p-1), 2 ^ (p-1), ... (p-1)^(p-1)}
*/
func ComputeFieldOrderPower() {
	orders := []int{7, 11, 17, 19, 31}
	for _, p := range orders {
		fmt.Printf("value of p is: %d\n", p)
		for i := 1; i < p; i++ {
			elm := NewFieldElement(big.NewInt(int64(p)), big.NewInt(int64(i)))
			fmt.Printf("for element: %v, its power of p - 1 is: %v\n", elm,
				elm.Pow(big.NewInt(int64(p-1))))
		}
		fmt.Println("-------------------------------")
	}
}

func TestOne(t *testing.T) {
	f44 := NewFieldElement(big.NewInt(57), big.NewInt(44))
	f33 := NewFieldElement(big.NewInt(57), big.NewInt(33))
	// 44 + 33 equal to (44+33) % 57 is 20
	res := f44.Add(f33)
	fmt.Printf("field element 44 add to field element 33 is : %v\n", res)
	//-44 is the negate of field element 44, which is 57 - 44 = 13
	fmt.Printf("negate of field element 44 is : %v\n", f44.Negate())

	fmt.Printf("field element 44 - 33 is : %v\n", f44.Sub(f33))
	fmt.Printf("field element 33 - 44 is : %v\n", f33.Sub(f44))

	//it is easy to check (11+33)%57 == 44
	//check (46 + 44) % 57 == 33
	fmt.Printf("check 46 + 44 over modulur 57 is %d\n", (46+44)%57)
	//check by field element
	f46 := NewFieldElement(big.NewInt(57), big.NewInt(46))
	fmt.Printf("field element 46 + 44 is %v\n", f46.Add(f44))

	SolveField19MultiplySet()

	ComputeFieldOrderPower()
}

func TestTwo(t *testing.T) {
	f2 := NewFieldElement(big.NewInt(int64(19)), big.NewInt(int64(2)))
	f7 := NewFieldElement(big.NewInt(int64(19)), big.NewInt(int64(7)))
	fmt.Printf("field element 2 / 7 with order 19 is %v\n", f2.Div(f7))

	f46 := NewFieldElement(big.NewInt(57), big.NewInt(46))
	fmt.Printf("field element 46 * 46 with order 57: %v\n", f46.Mul(f46))
	fmt.Printf("field element 46 ^ (58) is %v\n", f46.Pow(big.NewInt(int64(58))))
}

func TestThree(t *testing.T) {
	x1 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(192)))
	y1 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(105)))
	a := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(0)))
	b := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(7)))
	p1 := NewECPoint(x1, y1, a, b)
	fmt.Printf("2*(192,105) is  %s\n", p1.ScalarMul(big.NewInt(int64(2))))

	x2 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(143)))
	y2 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(98)))
	p2 := NewECPoint(x2, y2, a, b)

	fmt.Printf("2*(143,98) is %s\n", p2.ScalarMul(big.NewInt(int64(2))))

	x3 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(47)))
	y3 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(71)))
	p3 := NewECPoint(x3, y3, a, b)
	fmt.Printf("2*(47,71) is %s\n", p3.ScalarMul(big.NewInt(int64(2))))
	/*
		    practise:
			4*(47, 71), 8*(47,71), 21*(47,71)
	*/
	x4 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(47)))
	y4 := NewFieldElement(big.NewInt(int64(223)), big.NewInt(int64(71)))
	p4 := NewECPoint(x4, y4, a, b)
	fmt.Printf("4*(47,71) is %s\n", p4.ScalarMul(big.NewInt(int64(4))))
	fmt.Printf("8*(47,71) is %s\n", p4.ScalarMul(big.NewInt(int64(8))))
	fmt.Printf("21*(47,71) is %s\n", p4.ScalarMul(big.NewInt(int64(21))))
}

func TestFour(t *testing.T) {
	/*
		        P(x,y)= (
		             0x4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574ï¼Œ
		             82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4
				)

				z: 0xbc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423
				r: 37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6
				s: 8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec

				R is public key used to verify the message, z is hashed message,
				s is generated by using z and private key e,
				Verify should return true
	*/
	n := new(big.Int)
	n.SetString("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16)

	zVal := new(big.Int)
	zVal.SetString("bc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423", 16)
	zField := NewFieldElement(n, zVal)

	rVal := new(big.Int)
	rVal.SetString("37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6", 16)
	rField := NewFieldElement(n, rVal)

	sVal := new(big.Int)
	sVal.SetString("8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec", 16)
	sField := NewFieldElement(n, sVal)

	//public key
	px := new(big.Int)
	px.SetString("4519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574", 16)
	py := new(big.Int)
	py.SetString("82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4", 16)
	point := S256Point(px, py)
	fmt.Printf("point is: %s\n", point)

	sig := NewSignature(rField, sField)
	verifyRes := point.Verify(zField, sig)
	fmt.Printf("verify result is %v\n", verifyRes)
}

func TestFive(t *testing.T) {
	e := big.NewInt(int64(12345))
	z := new(big.Int)
	z.SetBytes(Hash256("Tesing my Signing"))

	privateKey := NewPrivateKey(e)
	sig := privateKey.Sign(z)
	fmt.Printf("sig is %s\n", sig)

	pubKey := privateKey.GetPublicKey()
	n := GetBitCoinValueN()
	zField := NewFieldElement(n, z)
	res := pubKey.Verify(zField, sig)
	fmt.Printf("verify signature result: %v\n", res)
}

func TestSix(t *testing.T) {
	p := new(big.Int)
	p.SetString("12345678", 16)
	bytes := p.Bytes()
	fmt.Printf("bytes for 0x12345678 is %x\n", bytes)

	littleEndianByte := BigIntToLittleEndian(p, LittleEndian4Bytes)
	fmt.Printf("little endian for 0x12345678 is %x\n", littleEndianByte)

	littleEndianByteToInt64 := LittleEndianToBigInt(littleEndianByte, LittleEndian4Bytes)
	fmt.Printf("little endian bytes into int is %x\n", littleEndianByteToInt64)
}
